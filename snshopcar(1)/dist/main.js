/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsQ0FBSjs7QUFFQTtBQUNBQSxJQUFLLFlBQVc7QUFDZixRQUFPLElBQVA7QUFDQSxDQUZHLEVBQUo7O0FBSUEsSUFBSTtBQUNIO0FBQ0FBLEtBQUlBLEtBQUtDLFNBQVMsYUFBVCxHQUFMLElBQWtDLENBQUMsR0FBRUMsSUFBSCxFQUFTLE1BQVQsQ0FBdEM7QUFDQSxDQUhELENBR0UsT0FBTUMsQ0FBTixFQUFTO0FBQ1Y7QUFDQSxLQUFHLFFBQU9DLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBckIsRUFDQ0osSUFBSUksTUFBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQk4sQ0FBakIiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n\tdata() {\n\t\treturn {\n\t\t\tname: \"ning\"\n\t\t};\n\t}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpc3QudnVlPzAwMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTUE7UUFFQTs7U0FHQTtBQUZBO0FBR0E7QUFMQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG5cdDxkaXY+XHJcblx0XHR7e25iYW1lfX1cclxuXHQ8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRkYXRhKCl7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0bmFtZSA6IFwibmluZ1wiXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbjwvc3R5bGU+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9saXN0LnZ1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _vue = __webpack_require__(3);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _list = __webpack_require__(7);\n\nvar _list2 = _interopRequireDefault(_list);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar vm = new _vue2.default({\n\tel: \"#box\",\n\ttemplate: \"<div><List/></div>\",\n\tcomponents: {\n\t\tList: _list2.default\n\t}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJ2bSIsImVsIiwidGVtcGxhdGUiLCJjb21wb25lbnRzIiwiTGlzdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOzs7Ozs7QUFDQSxJQUFJQSxLQUFLLGtCQUFRO0FBQ2hCQyxLQUFLLE1BRFc7QUFFaEJDLFdBQVcsb0JBRks7QUFHaEJDLGFBQVk7QUFDWEM7QUFEVztBQUhJLENBQVIsQ0FBVCIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tIFwidnVlXCI7XHJcbmltcG9ydCBsaXN0IGZyb20gXCIuL2xpc3QudnVlXCJcclxubGV0IHZtID0gbmV3IFZ1ZSh7XHJcblx0ZWwgOiBcIiNib3hcIixcclxuXHR0ZW1wbGF0ZSA6IFwiPGRpdj48TGlzdC8+PC9kaXY+XCIsXHJcblx0Y29tcG9uZW50cyA6e1xyXG5cdFx0TGlzdCA6IGxpc3RcclxuXHR9XHJcbn0pXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Vue.js v2.5.16\n * (c) 2014-2018 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();\n})(undefined, function () {\n  'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // these helpers produces better vm code in JS engines due to their\n  // explicitness and function inlining\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n\n  /**\n   * Check if value is primitive\n   */\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' ||\n    // $flow-disable-line\n    (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n  }\n\n  /**\n   * Get the raw type string of a value e.g. [object Object]\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString(val) {\n    return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n  }\n\n  /**\n   * Convert a input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if a attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array\n   */\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Check whether the object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it... e.g.\n   * PhantomJS 1.x. Technically we don't need this anymore since native bind is\n   * now more performant in most browsers, but removing it would be breaking for\n   * code that was able to run in PhantomJS 1.x, so this must be kept for\n   * backwards compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to;\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject(arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n   */\n  function noop(a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function no(a, b, c) {\n    return false;\n  };\n\n  /**\n   * Return same value\n   */\n  var identity = function identity(_) {\n    return _;\n  };\n\n  /**\n   * Generate a static keys string from compiler modules.\n   */\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];\n\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n\n  /*  */\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Define a property.\n   */\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = /[^\\w.$]/;\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n        obj = obj[segments[i]];\n      }\n      return obj;\n    };\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = {}.watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function isServerRendering() {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer;\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n  var formatComponentName = noop;\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function classify(str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function warn(msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function tip(msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function formatComponentName(vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function repeat(str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n        if (n > 1) {\n          str += str;\n        }\n        n >>= 1;\n      }\n      return res;\n    };\n\n    generateComponentTrace = function generateComponentTrace(vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(_target) {\n    if (Dep.target) {\n      targetStack.push(Dep.target);\n    }\n    Dep.target = _target;\n  }\n\n  function popTarget() {\n    Dep.target = targetStack.pop();\n  }\n\n  /*  */\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function createEmptyVNode(text) {\n    if (text === void 0) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.isCloned = true;\n    return cloned;\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) {\n        ob.observeArray(inserted);\n      }\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      var augment = hasProto ? protoAugment : copyAugment;\n      augment(value, arrayMethods, arrayKeys);\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment(target, src, keys) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    if (!getter && arguments.length === 2) {\n      val = obj[key];\n    }\n    var setter = property && property.set;\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n        if (\"development\" !== 'production' && customSetter) {\n          customSetter();\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set(target, key, val) {\n    if (\"development\" !== 'production' && (isUndef(target) || isPrimitive(target))) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n    defineReactive(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del(target, key) {\n    if (\"development\" !== 'production' && (isUndef(target) || isPrimitive(target))) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n    if (!hasOwn(target, key)) {\n      return;\n    }\n    delete target[key];\n    if (!ob) {\n      return;\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n      return defaultStrat(parent, child);\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n    var key, toVal, fromVal;\n    var keys = Object.keys(from);\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        \"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\n        return parentVal;\n      }\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook(parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      \"development\" !== 'production' && assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) {\n      extend(ret, childVal);\n    }\n    return ret;\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps(options, vm) {\n    var props = options.props;\n    if (!props) {\n      return;\n    }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : { type: val };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n    if (!inject) {\n      return;\n    }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def = dirs[key];\n        if (typeof def === 'function') {\n          dirs[key] = { bind: def, update: def };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n    var extendsFrom = child.extends;\n    if (extendsFrom) {\n      parent = mergeOptions(parent, extendsFrom, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (\"development\" !== 'production' && warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n    return res;\n  }\n\n  /*  */\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (\"development\" !== 'production' && isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n    if (value == null && !prop.required) {\n      return;\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n    if (!valid) {\n      warn(\"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ') + \", got \" + toRawType(value) + \".\", vm);\n      return;\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /*  */\n\n  function handleError(err, vm, info) {\n    if (vm) {\n      var cur = vm;\n      while (cur = cur.$parent) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) {\n                return;\n              }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /*  */\n  /* globals MessageChannel */\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using both microtasks and (macro) tasks.\n  // In < 2.4 we used microtasks everywhere, but there are some scenarios where\n  // microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690) or even between bubbling of the same\n  // event (#6566). However, using (macro) tasks everywhere also has subtle problems\n  // when state is changed right before repaint (e.g. #6813, out-in transitions).\n  // Here we use microtask by default, but expose a way to force (macro) task when\n  // needed (e.g. in event handlers attached by v-on).\n  var microTimerFunc;\n  var macroTimerFunc;\n  var useMacroTask = false;\n\n  // Determine (macro) task defer implementation.\n  // Technically setImmediate should be the ideal choice, but it's only available\n  // in IE. The only polyfill that consistently queues the callback after all DOM\n  // events triggered in the same loop is by using MessageChannel.\n  /* istanbul ignore if */\n  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    macroTimerFunc = function macroTimerFunc() {\n      setImmediate(flushCallbacks);\n    };\n  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]')) {\n    var channel = new MessageChannel();\n    var port = channel.port2;\n    channel.port1.onmessage = flushCallbacks;\n    macroTimerFunc = function macroTimerFunc() {\n      port.postMessage(1);\n    };\n  } else {\n    /* istanbul ignore next */\n    macroTimerFunc = function macroTimerFunc() {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  // Determine microtask defer implementation.\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    microTimerFunc = function microTimerFunc() {\n      p.then(flushCallbacks);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else {\n    // fallback to macro\n    microTimerFunc = macroTimerFunc;\n  }\n\n  /**\n   * Wrap a function so that if any code inside triggers state change,\n   * the changes are queued using a (macro) task instead of a microtask.\n   */\n  function withMacroTask(fn) {\n    return fn._withTask || (fn._withTask = function () {\n      useMacroTask = true;\n      var res = fn.apply(null, arguments);\n      useMacroTask = false;\n      return res;\n    });\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      if (useMacroTask) {\n        macroTimerFunc();\n      } else {\n        microTimerFunc();\n      }\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function mark(tag) {\n        return perf.mark(tag);\n      };\n      measure = function measure(name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        perf.clearMeasures(name);\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function warnNonPresent(target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n        if (!has && !isAllowed) {\n          warnNonPresent(target, key);\n        }\n        return has || !isAllowed;\n      }\n    };\n\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          warnNonPresent(target, key);\n        }\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse(val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns) {\n    function invoker() {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          cloned[i].apply(null, arguments$1);\n        }\n      } else {\n        // return handler return value for single handlers\n        return fns.apply(null, arguments);\n      }\n    }\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, vm) {\n    var name, def, cur, old, event;\n    for (name in on) {\n      def = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      /* istanbul ignore if */\n      if (isUndef(cur)) {\n        \"development\" !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur);\n        }\n        add(event.name, cur, event.once, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return;\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n    return children;\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i);\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor, context) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (isDef(factory.contexts)) {\n      // already pending\n      factory.contexts.push(context);\n    } else {\n      var contexts = factory.contexts = [context];\n      var sync = true;\n\n      var forceRender = function forceRender() {\n        for (var i = 0, l = contexts.length; i < l; i++) {\n          contexts[i].$forceUpdate();\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender();\n        }\n      });\n\n      var reject = once(function (reason) {\n        \"development\" !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender();\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (typeof res.then === 'function') {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isDef(res.component) && typeof res.component.then === 'function') {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              setTimeout(function () {\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender();\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            setTimeout(function () {\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n\n  /*  */\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn, once) {\n    if (once) {\n      target.$once(event, fn);\n    } else {\n      target.$on(event, fn);\n    }\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var this$1 = this;\n\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var this$1 = this;\n\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$off(event[i], fn);\n        }\n        return vm;\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm;\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      }\n      if (fn) {\n        // specific handler\n        var cb;\n        var i$1 = cbs.length;\n        while (i$1--) {\n          cb = cbs[i$1];\n          if (cb === fn || cb.fn === fn) {\n            cbs.splice(i$1, 1);\n            break;\n          }\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          try {\n            cbs[i].apply(vm, args);\n          } catch (e) {\n            handleError(e, vm, \"event handler for \\\"\" + event + \"\\\"\");\n          }\n        }\n      }\n      return vm;\n    };\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots(children, context) {\n    var slots = {};\n    if (!children) {\n      return slots;\n    }\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res) {\n    res = res || {};\n    for (var i = 0; i < fns.length; i++) {\n      if (Array.isArray(fns[i])) {\n        resolveScopedSlots(fns[i], res);\n      } else {\n        res[fns[i].key] = fns[i].fn;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function initLifecycle(vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate');\n      }\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var prevActiveInstance = activeInstance;\n      activeInstance = vm;\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n        , vm.$options._parentElm, vm.$options._refElm);\n        // no need for the ref nodes after initial patch\n        // this prevents keeping a detached DOM tree in memory (#5851)\n        vm.$options._parentElm = vm.$options._refElm = null;\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      activeInstance = prevActiveInstance;\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && config.performance && mark) {\n      updateComponent = function updateComponent() {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function updateComponent() {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren\n    var hasChildren = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        try {\n          handlers[i].call(vm);\n        } catch (e) {\n          handleError(e, vm, hook + \" hook\");\n        }\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue() {\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (\"development\" !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n  var uid$1 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$1; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = function () {};\n        \"development\" !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n    this.value = this.lazy ? undefined : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value;\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var this$1 = this;\n\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this$1.deps[i];\n      if (!this$1.newDepIds.has(dep.id)) {\n        dep.removeSub(this$1);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n      if (value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend() {\n    var this$1 = this;\n\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown() {\n    var this$1 = this;\n\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this$1.deps[i].removeSub(this$1);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function loop(key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n        defineReactive(props, key, value, function () {\n          if (vm.$parent && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) {\n      loop(key);\n    }toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      \"development\" !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        \"development\" !== 'production' && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (\"development\" !== 'production' && getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n    }\n    if (\"development\" !== 'production' && sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      }\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (methods[key] == null) {\n          warn(\"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () {\n      return this._data;\n    };\n    var propsDef = {};\n    propsDef.get = function () {\n      return this._props;\n    };\n    {\n      dataDef.set = function (newData) {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n\n  /*  */\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable;\n      }) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n      return result;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    if (isDef(ret)) {\n      ret._isVList = true;\n    }\n    return ret;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (\"development\" !== 'production' && !isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes) {\n        if (\"development\" !== 'production' && slotNodes._rendered) {\n          warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n        }\n        slotNodes._rendered = true;\n      }\n      nodes = slotNodes || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n\n  /*  */\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        \"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function loop(key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n          if (!(key in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) {\n          loop(key);\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree;\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        \"development\" !== 'production' && warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      return resolveSlots(children, parent);\n    };\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = data.scopedSlots || emptyObject;\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);\n      }\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  // Register the component hook to weex native render engine.\n  // The hook will be triggered by native, not javascript.\n\n\n  // Updates the state of the component to weex native render engine.\n\n  /*  */\n\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n  // listening on native callback\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating, parentElm, refElm) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n\n    // Weex specific: invoke recycle-list optimized @render function for\n    // extracting cell-slot template.\n    // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n    /* istanbul ignore if */\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm, refElm) {\n    var options = {\n      _isComponent: true,\n      parent: parent,\n      _parentVnode: vnode,\n      _parentElm: parentElm || null,\n      _refElm: refElm || null\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      hooks[key] = componentVNodeHooks[key];\n    }\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    if (isDef(on[event])) {\n      on[event] = [data.model.callback].concat(on[event]);\n    } else {\n      on[event] = data.model.callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      \"development\" !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (\"development\" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      // reset _rendered flag on slots for duplicate slot check\n      {\n        for (var key in vm.$slots) {\n          // $flow-disable-line\n          vm.$slots[key]._rendered = false;\n        }\n      }\n\n      if (_parentVnode) {\n        vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        {\n          if (vm.$options.renderError) {\n            try {\n              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n            } catch (e) {\n              handleError(e, vm, \"renderError\");\n              vnode = vm._vnode;\n            }\n          } else {\n            vnode = vm._vnode;\n          }\n        }\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (\"development\" !== 'production' && Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    opts._parentElm = options._parentElm;\n    opts._refElm = options._refElm;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var extended = Ctor.extendOptions;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n        modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n      }\n    }\n    return modified;\n  }\n\n  function dedupe(latest, extended, sealed) {\n    // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n    // between merges\n    if (Array.isArray(latest)) {\n      var res = [];\n      sealed = Array.isArray(sealed) ? sealed : [sealed];\n      extended = Array.isArray(extended) ? extended : [extended];\n      for (var i = 0; i < latest.length; i++) {\n        // push original options and not sealed options to exclude duplicated options\n        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n          res.push(latest[i]);\n        }\n      }\n      return res;\n    } else {\n      return latest;\n    }\n  }\n\n  function Vue(options) {\n    if (\"development\" !== 'production' && !(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (\"development\" !== 'production' && name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (\"development\" !== 'production' && type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n\n  /*  */\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed() {\n      var this$1 = this;\n\n      for (var key in this$1.cache) {\n        pruneCacheEntry(this$1.cache, key, this$1.keys);\n      }\n    },\n\n    mounted: function mounted() {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n        // not included\n        include && (!name || !matches(include, name)) ||\n        // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || slot && slot[0];\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n\n    /*  */\n\n  };function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () {\n      return config;\n    };\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.5.16';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function mustUseProp(tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n\n  /*  */\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n        res += stringified;\n      }\n    }\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n        res += key;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n    if (isReservedTag(tag)) {\n      return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        \"development\" !== 'production' && warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n      return selected;\n    } else {\n      return el;\n    }\n  }\n\n  /*  */\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm;\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove() {\n        if (--remove.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove.listeners = listeners;\n      return remove;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (\"development\" !== 'production' && data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */, parentElm, refElm);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (ref$$1.parentNode === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return;\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true /* hydrating */);\n        }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (\"development\" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (\"development\" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false;\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm$1 = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(vnode, insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm$1)) {\n            removeVnodes(parentElm$1, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function callInsert() {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {\n        var blocker = function blocker(e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n\n    /*  */\n\n  };function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n\n    /*  */\n\n  };var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x60:\n            inTemplateString = true;break; // `\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0;\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') {\n              break;\n            }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n\n  /*  */\n\n  function baseWarn(msg) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value) {\n    (el.props || (el.props = [])).push({ name: name, value: value });\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value) {\n    (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr(el, name, value) {\n    el.attrsMap[name] = value;\n    el.attrsList.push({ name: name, value: value });\n  }\n\n  function addDirective(el, name, rawName, value, arg, modifiers) {\n    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n    el.plain = false;\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = '!' + name; // mark the event as captured\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = '~' + name; // mark the event as once\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = '&' + name; // mark the event as passive\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (name === 'click') {\n      if (modifiers.right) {\n        name = 'contextmenu';\n        delete modifiers.right;\n      } else if (modifiers.middle) {\n        name = 'mouseup';\n      }\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = {\n      value: value.trim()\n    };\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val;\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: \"\\\"\" + value + \"\\\"\",\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len;\n  var str;\n  var chr;\n  var index$1;\n  var expressionPos;\n  var expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n    }\n\n    // ensure runtime directive metadata\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally');\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler(handler, event, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  }\n\n  function add$1(event, handler, once$$1, capture, passive) {\n    handler = withMacroTask(handler);\n    if (once$$1) {\n      handler = createOnceHandler(handler, event, capture);\n    }\n    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n  }\n\n  function remove$2(event, handler, capture, _target) {\n    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n\n    /*  */\n\n  };function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (isUndef(props[key])) {\n        elm[key] = '';\n      }\n    }\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n        if (cur === oldProps[key]) {\n          continue;\n        }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else {\n        elm[key] = cur;\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.lazy) {\n        // inputs with lazy should only be updated when not in focus\n        return false;\n      }\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n\n    /*  */\n\n  };var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n    return bindingStyle;\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function setProp(el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n\n    /*  */\n\n    /**\n     * Add class with compatibility for SVG since classList is not supported on\n     * SVG elements in IE\n     */\n  };function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition(def) {\n    if (!def) {\n      return;\n    }\n    /* istanbul ignore else */\n    if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {\n      var res = {};\n      if (def.css !== false) {\n        extend(res, autoCssTransition(def.name || 'v'));\n      }\n      extend(res, def);\n      return res;\n    } else if (typeof def === 'string') {\n      return autoCssTransition(def);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) {\n      return cb();\n    }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function onEnd(e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = styles[animationProp + 'Delay'].split(', ');\n    var animationDurations = styles[animationProp + 'Duration'].split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  }\n\n  function toMs(s) {\n    return Number(s.slice(0, -1)) * 1000;\n  }\n\n  /*  */\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return;\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      transitionNode = transitionNode.parent;\n      context = transitionNode.context;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (\"development\" !== 'production' && explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      }\n      // record leaving element\n      if (!vnode.data.show) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      \"development\" !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return;\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) {\n        return;\n      }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n\n    /*  */\n\n    // Provides transition support for a single element/component.\n    // supports transition mode (out-in / in-out)\n\n  };var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render(h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return;\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(function (c) {\n        return c.tag || isAsyncPlaceholder(c);\n      });\n      /* istanbul ignore if */\n      if (!children.length) {\n        return;\n      }\n\n      // warn multiple elements\n      if (\"development\" !== 'production' && children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(function (d) {\n        return d.name === 'show';\n      })) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n          var delayedLeave;\n          var performLeave = function performLeave() {\n            delayedLeave();\n          };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n\n    /*  */\n\n    // Provides transition support for list items.\n    // supports move transitions using the FLIP technique.\n\n    // Because the vdom's children update algorithm is \"unstable\" - i.e.\n    // it doesn't guarantee the relative positioning of removed elements,\n    // we force transition-group to update its children into two passes:\n    // in the first pass, we remove all nodes that need to be removed,\n    // triggering their leaving transition; in the second pass, we insert/move\n    // into the final desired state. This way in the second pass removed\n    // nodes will remain where they should be.\n\n  };var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n\n    beforeUpdate: function beforeUpdate() {\n      // force removing pass\n      this.__patch__(this._vnode, this.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this._vnode = this.kept;\n    },\n\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove;\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n\n    /*  */\n\n    // install platform specific utils\n  };Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else if (\"development\" !== 'production' && \"development\" !== 'test' && isChrome) {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n      if (\"development\" !== 'production' && \"development\" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return;\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while (match = tagRE.exec(text)) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n\n  /*  */\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (\"development\" !== 'production' && staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n\n    /*  */\n\n  };function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n\n    /*  */\n\n  };var decoder;\n\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n\n    /*  */\n\n  };var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  /*!\n   * HTML Parser By John Resig (ejohn.org)\n   * Modified by Juriy \"kangax\" Zaytsev\n   * Original code by Erik Arvidsson, Mozilla Public License\n   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n  // but for Vue templates we can enforce a simple charset\n  var ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being pased as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  var IS_REGEX_CAPTURING_BROKEN = false;\n  'x'.replace(/x(.)?/g, function (m, g) {\n    IS_REGEX_CAPTURING_BROKEN = g === '';\n  });\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t'\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd));\n              }\n              advance(commentEnd + 3);\n              continue;\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(lastTag, html)) {\n              advance(1);\n            }\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) {\n              break;\n            }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n          advance(textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n          html = '';\n        }\n\n        if (options.chars && text) {\n          options.chars(text);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (\"development\" !== 'production' && !stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n        }\n        break;\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n          advance(attr[0].length);\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') {\n            delete args[3];\n          }\n          if (args[4] === '') {\n            delete args[4];\n          }\n          if (args[5] === '') {\n            delete args[5];\n          }\n        }\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) {\n        start = index;\n      }\n      if (end == null) {\n        end = index;\n      }\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n      }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (\"development\" !== 'production' && (i > pos || !tagName) && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([^]*?)\\s+(?:in|of)\\s+([^]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^v-bind:/;\n  var modifierRE = /\\.[^.]+/g;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      parent: parent,\n      children: []\n    };\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg);\n      }\n    }\n\n    function closeElement(element) {\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      start: function start(tag, attrs, unary) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          \"development\" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n          // element-scope stuff\n          processElement(element, options);\n        }\n\n        function checkRootConstraints(el) {\n          {\n            if (el.tag === 'slot' || el.tag === 'template') {\n              warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n            }\n            if (el.attrsMap.hasOwnProperty('v-for')) {\n              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n            }\n          }\n        }\n\n        // tree management\n        if (!root) {\n          root = element;\n          checkRootConstraints(root);\n        } else if (!stack.length) {\n          // allow root elements with v-if, v-else-if and v-else\n          if (root.if && (element.elseif || element.else)) {\n            checkRootConstraints(element);\n            addIfCondition(root, {\n              exp: element.elseif,\n              block: element\n            });\n          } else {\n            warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n          }\n        }\n        if (currentParent && !element.forbidden) {\n          if (element.elseif || element.else) {\n            processIfConditions(element, currentParent);\n          } else if (element.slotScope) {\n            // scoped slot\n            currentParent.plain = false;\n            var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          } else {\n            currentParent.children.push(element);\n            element.parent = currentParent;\n          }\n        }\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end() {\n        // remove trailing whitespace\n        var element = stack[stack.length - 1];\n        var lastNode = element.children[element.children.length - 1];\n        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n          element.children.pop();\n        }\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        closeElement(element);\n      },\n\n      chars: function chars(text) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.');\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n            }\n          }\n          return;\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n        var children = currentParent.children;\n        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n        if (text) {\n          var res;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            children.push({\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            });\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            children.push({\n              type: 3,\n              text: text\n            });\n          }\n        }\n      },\n      comment: function comment(text) {\n        currentParent.children.push({\n          type: 3,\n          text: text,\n          isComment: true\n        });\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var l = el.attrsList.length;\n    if (l) {\n      var attrs = el.attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        attrs[i] = {\n          name: el.attrsList[i].name,\n          value: JSON.stringify(el.attrsList[i].value)\n        };\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = !element.key && !element.attrsList.length;\n\n    processRef(element);\n    processSlot(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      if (\"development\" !== 'production' && el.tag === 'template') {\n        warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      return;\n    }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '');\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (\"development\" !== 'production' && children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  function processSlot(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (\"development\" !== 'production' && el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n      }\n    } else {\n      var slotScope;\n      if (el.tag === 'template') {\n        slotScope = getAndRemoveAttr(el, 'scope');\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && slotScope) {\n          warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", true);\n        }\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && el.attrsMap['v-for']) {\n          warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", true);\n        }\n        el.slotScope = slotScope;\n      }\n      var slotTarget = getBindingAttr(el, 'slot');\n      if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n        // preserve slot as an attribute for native shadow DOM compat\n        // only for non-scoped slots.\n        if (el.tag !== 'template' && !el.slotScope) {\n          addAttr(el, 'slot', slotTarget);\n        }\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, isProp;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name);\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isProp = false;\n          if (modifiers) {\n            if (modifiers.prop) {\n              isProp = true;\n              name = camelize(name);\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n            if (modifiers.camel) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n            }\n          }\n          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value);\n          } else {\n            addAttr(el, name, value);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          addHandler(el, name, value, modifiers, false, warn$2);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n          }\n          addDirective(el, name, rawName, value, arg, modifiers);\n          if (\"development\" !== 'production' && name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n          }\n        }\n        addAttr(el, name, JSON.stringify(value));\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true');\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\"development\" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug(attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n   * Turn this:\n   *   <input v-model=\"data[type]\" :type=\"type\">\n   * into this:\n   *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n   *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n   *   <input v-else :type=\"type\" v-model=\"data[type]\">\n   */\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$2 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [klass$1, style$1, model$2];\n\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  /*  */\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n\n    /*  */\n\n  };var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false;\n      }\n      if (node.for) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    esc: 'Escape',\n    tab: 'Tab',\n    enter: 'Enter',\n    space: ' ',\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    'delete': ['Backspace', 'Delete']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function genGuard(condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative, warn) {\n    var res = isNative ? 'nativeOn:{' : 'on:{';\n    for (var name in events) {\n      res += \"\\\"\" + name + \"\\\":\" + genHandler(name, events[name]) + \",\";\n    }\n    return res.slice(0, -1) + '}';\n  }\n\n  function genHandler(name, handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(name, handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n      /* istanbul ignore if */\n      return \"function($event){\" + handler.value + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : handler.value;\n      /* istanbul ignore if */\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n\n  /*  */\n\n  function on(el, dir) {\n    if (\"development\" !== 'production' && dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n\n  /*  */\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n\n    /*  */\n\n  };var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) {\n      return !isReservedTag(el.tag);\n    };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data = el.plain ? undefined : genData$2(el, state);\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code;\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic(el, state) {\n    el.staticProcessed = true;\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  }\n\n  // v-once\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        \"development\" !== 'production' && state.warn(\"v-once can only be used inside v-for that is keyed. \");\n        return genElement(el, state);\n      }\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (\"development\" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) {\n      data += dirs + ',';\n    }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:{\" + genProps(el.props) + \"},\";\n    }\n    // event handlers\n    if (el.events) {\n      data += genHandlers(el.events, false, state.warn) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true, state.warn) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += genScopedSlots(el.scopedSlots, state) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n    if (!dirs) {\n      return;\n    }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n    if (\"development\" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {\n      state.warn('Inline-template components must have exactly one child element.');\n    }\n    if (ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(slots, state) {\n    return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state);\n    }).join(',') + \"])\";\n  }\n\n  function genScopedSlot(key, el, state) {\n    if (el.for && !el.forProcessed) {\n      return genForScopedSlot(key, el, state);\n    }\n    var fn = \"function(\" + String(el.slotScope) + \"){\" + \"return \" + (el.tag === 'template' ? el.if ? el.if + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\";\n    return \"{key:\" + key + \",fn:\" + fn + \"}\";\n  }\n\n  function genForScopedSlot(key, el, state) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n    el.forProcessed = true; // avoid recursion\n    return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el, state) + '})';\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        return (altGenElement || genElement)(el$1, state);\n      }\n      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue;\n      }\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    }if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n      return camelize(a.name) + \":\" + a.value;\n    }).join(',') + \"}\";\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')';\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var res = '';\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      /* istanbul ignore if */\n      {\n        res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n      }\n    }\n    return res.slice(0, -1);\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n\n  /*  */\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors(ast) {\n    var errors = [];\n    if (ast) {\n      checkNode(ast, errors);\n    }\n    return errors;\n  }\n\n  function checkNode(node, errors) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], errors);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, errors);\n    }\n  }\n\n  function checkEvent(exp, text, errors) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    }\n    checkExpression(exp, text, errors);\n  }\n\n  function checkFor(node, text, errors) {\n    checkExpression(node.for || '', text, errors);\n    checkIdentifier(node.alias, 'v-for alias', text, errors);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n  }\n\n  function checkIdentifier(ident, type, text, errors) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n      }\n    }\n  }\n\n  function checkExpression(exp, text, errors) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim());\n      } else {\n        errors.push(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\");\n      }\n    }\n  }\n\n  /*  */\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n      if (cache[key]) {\n        return cache[key];\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n            return \"- \" + e;\n          }).join('\\n') + '\\n', vm);\n        }\n        if (compiled.tips && compiled.tips.length) {\n          compiled.tips.forEach(function (msg) {\n            return tip(msg, vm);\n          });\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n\n      return cache[key] = res;\n    };\n  }\n\n  /*  */\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n        finalOptions.warn = function (msg, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        var compiled = baseCompile(template, finalOptions);\n        {\n          errors.push.apply(errors, detectErrors(compiled.ast));\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      \"development\" !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (\"development\" !== 'production' && !template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating);\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(4).setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Z1ZUAyLjUuMTZAdnVlL2Rpc3QvdnVlLmpzPzM5YmUiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJWdWUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJGdW5jdGlvbiIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwid2luZG93IiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZXJyb3IiLCJpbmNsdWRlRmlsZSIsIiRyb290Iiwib3B0aW9ucyIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInB1c2giLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJsZW4iLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwidHlwZSIsImtleSQxIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJsb2dFcnJvciIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsIm1pY3JvVGltZXJGdW5jIiwibWFjcm9UaW1lckZ1bmMiLCJ1c2VNYWNyb1Rhc2siLCJzZXRJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwic2V0VGltZW91dCIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsInRoZW4iLCJ3aXRoTWFjcm9UYXNrIiwiX3dpdGhUYXNrIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlJCQxIiwib2xkIiwiZXZlbnQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWplY3QiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJ0aGlzJDEiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQxIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInByb3h5Iiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiaHlwaGVuYXRlZEtleSIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsImlzU1NSIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiJGRhdGEiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJHNldCIsIiRkZWxldGUiLCJpbW1lZGlhdGUiLCJ1bndhdGNoRm4iLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImZpbHRlciIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJwcm92aWRlRGVmYXVsdCIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwibm9kZXMiLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwiaW5zdGFsbFJlbmRlckhlbHBlcnMiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImluamVjdGlvbnMiLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0Iiwidm5vZGVzIiwiY2xvbmUiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsInBhcmVudEVsbSIsInJlZkVsbSIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJpbnNlcnQiLCJkZXN0cm95IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZWYiLCJyZW5kZXJFcnJvciIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJOdW1iZXIiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVsZXRlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiZG9jdW1lbnQiLCJIVE1MVW5rbm93bkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzVGV4dElucHV0VHlwZSIsInF1ZXJ5Iiwic2VsZWN0ZWQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsIm11bHRpcGxlIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwibmFtZXNwYWNlIiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJzb21lIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJvd25lckFycmF5IiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJwbGFpbiIsImFkZEF0dHIiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsIm5leHQiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidmFsdWUkMSIsInR5cGVCaW5kaW5nIiwiYmluZGluZyIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9uY2VIYW5kbGVyIiwicmVtb3ZlJDIiLCJhZGQkMSIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJlbGVtZW50IiwiY29tbWVudHMiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJmb3JiaWRkZW4iLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc0VsZW1lbnQiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja0luRm9yIiwicGFyc2VGb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQyIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIm1lc3NhZ2UiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztBQUtDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLGtDQUFPQyxPQUFQLE9BQW1CLFFBQW5CLElBQStCLE9BQU9DLE1BQVAsS0FBa0IsV0FBakQsR0FBK0RBLE9BQU9ELE9BQVAsR0FBaUJELFNBQWhGLEdBQ0EsUUFBNkMs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OztBQUVELzdCLE1BQUkyaUQsT0FBSixHQUFjQyxrQkFBZDs7QUFFQSxTQUFPNWlELEdBQVA7QUFFQyxDQTdyVkEsQ0FBRCxDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjE2XG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0Li4uIGUuZy5cbiAqIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlIHNpbmNlIG5hdGl2ZSBiaW5kIGlzXG4gKiBub3cgbW9yZSBwZXJmb3JtYW50IGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZW1vdmluZyBpdCB3b3VsZCBiZSBicmVha2luZyBmb3JcbiAqIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW4gUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yXG4gKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSlcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG57XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bSB8fCB7fTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICBpZiAoIWdldHRlciAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbntcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm90YXNrcyBhbmQgKG1hY3JvKSB0YXNrcy5cbi8vIEluIDwgMi40IHdlIHVzZWQgbWljcm90YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCkgb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lXG4vLyBldmVudCAoIzY1NjYpLiBIb3dldmVyLCB1c2luZyAobWFjcm8pIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNyb3Rhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSAobWFjcm8pIHRhc2sgd2hlblxuLy8gbmVlZGVkIChlLmcuIGluIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIGJ5IHYtb24pLlxudmFyIG1pY3JvVGltZXJGdW5jO1xudmFyIG1hY3JvVGltZXJGdW5jO1xudmFyIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuXG4vLyBEZXRlcm1pbmUgKG1hY3JvKSB0YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLy8gVGVjaG5pY2FsbHkgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB0aGUgaWRlYWwgY2hvaWNlLCBidXQgaXQncyBvbmx5IGF2YWlsYWJsZVxuLy8gaW4gSUUuIFRoZSBvbmx5IHBvbHlmaWxsIHRoYXQgY29uc2lzdGVudGx5IHF1ZXVlcyB0aGUgY2FsbGJhY2sgYWZ0ZXIgYWxsIERPTVxuLy8gZXZlbnRzIHRyaWdnZXJlZCBpbiB0aGUgc2FtZSBsb29wIGlzIGJ5IHVzaW5nIE1lc3NhZ2VDaGFubmVsLlxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTWVzc2FnZUNoYW5uZWwpIHx8XG4gIC8vIFBoYW50b21KU1xuICBNZXNzYWdlQ2hhbm5lbC50b1N0cmluZygpID09PSAnW29iamVjdCBNZXNzYWdlQ2hhbm5lbENvbnN0cnVjdG9yXSdcbikpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoQ2FsbGJhY2tzO1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKDEpO1xuICB9O1xufSBlbHNlIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbi8vIERldGVybWluZSBtaWNyb3Rhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIG1pY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gZmFsbGJhY2sgdG8gbWFjcm9cbiAgbWljcm9UaW1lckZ1bmMgPSBtYWNyb1RpbWVyRnVuYztcbn1cblxuLyoqXG4gKiBXcmFwIGEgZnVuY3Rpb24gc28gdGhhdCBpZiBhbnkgY29kZSBpbnNpZGUgdHJpZ2dlcnMgc3RhdGUgY2hhbmdlLFxuICogdGhlIGNoYW5nZXMgYXJlIHF1ZXVlZCB1c2luZyBhIChtYWNybykgdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxue1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxue1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiB1c2VyRGVmO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAge1xuICAgICAgaWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbiB1bmRlZmluZWQgdmFsdWUgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZVxuICAgICAgfSlcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzKSB7XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KTsgfTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zKSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG5cblxuXG4vLyBSZWdpc3RlciB0aGUgY29tcG9uZW50IGhvb2sgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cbi8vIFRoZSBob29rIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IG5hdGl2ZSwgbm90IGphdmFzY3JpcHQuXG5cblxuLy8gVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuXG4vKiAgKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuXG4vLyBsaXN0ZW5pbmcgb24gbmF0aXZlIGNhbGxiYWNrXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgLy8gV2VleCBzcGVjaWZpYzogaW52b2tlIHJlY3ljbGUtbGlzdCBvcHRpbWl6ZWQgQHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgLy8gZXh0cmFjdGluZyBjZWxsLXNsb3QgdGVtcGxhdGUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICBob29rc1trZXldID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgLy8gcmVzZXQgX3JlbmRlcmVkIGZsYWcgb24gc2xvdHMgZm9yIGR1cGxpY2F0ZSBzbG90IGNoZWNrXG4gICAge1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdm0uJHNsb3RzW2tleV0uX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi41LjE2JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufVxuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyAoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0ge1xuICAgIHZhbHVlOiB2YWx1ZS50cmltKClcbiAgfTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn1cblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge31cblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXVxuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufVxuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufVxuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAndGVzdCcgJiZcbiAgICAgICAgaXNDaHJvbWVcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufVxuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKFteXSo/KVxccysoPzppbnxvZilcXHMrKFteXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudC1zY29wZSBzdHVmZlxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJyk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBFeHBhbmQgaW5wdXRbdi1tb2RlbF0gd2l0aCBkeWFubWljIHR5cGUgYmluZGluZ3MgaW50byB2LWlmLWVsc2UgY2hhaW5zXG4gKiBUdXJuIHRoaXM6XG4gKiAgIDxpbnB1dCB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiIDp0eXBlPVwidHlwZVwiPlxuICogaW50byB0aGlzOlxuICogICA8aW5wdXQgdi1pZj1cInR5cGUgPT09ICdjaGVja2JveCdcIiB0eXBlPVwiY2hlY2tib3hcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlLWlmPVwidHlwZSA9PT0gJ3JhZGlvJ1wiIHR5cGU9XCJyYWRpb1wiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UgOnR5cGU9XCJ0eXBlXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn1cblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMlxuXVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn1cblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbnZhciBrZXlOYW1lcyA9IHtcbiAgZXNjOiAnRXNjYXBlJyxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIHNwYWNlOiAnICcsXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZSddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgcmVzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIChnZW5IYW5kbGVyKG5hbWUsIGV2ZW50c1tuYW1lXSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoXG4gIG5hbWUsXG4gIGhhbmRsZXJcbikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZighKCdidXR0b24nIGluICRldmVudCkmJlwiICsgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleUNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXksXCIgK1xuICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICBcIilcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn1cblxuLyogICovXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSwgc3RhdGUud2FybikpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWZcbiAgICAgICAgPyAoKGVsLmlmKSArIFwiP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46XCIgKyBmbiArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIGVycm9yc1xuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAge1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5yZXR1cm4gVnVlO1xuXG59KSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL192dWVAMi41LjE2QHZ1ZS9kaXN0L3Z1ZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(5);\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || undefined && undefined.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || undefined && undefined.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3RpbWVycy1icm93c2VyaWZ5QDIuMC4xMEB0aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzP2Y2YmYiXSwibmFtZXMiOlsic2NvcGUiLCJnbG9iYWwiLCJzZWxmIiwid2luZG93IiwiYXBwbHkiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImV4cG9ydHMiLCJzZXRUaW1lb3V0IiwiVGltZW91dCIsImNhbGwiLCJhcmd1bWVudHMiLCJjbGVhclRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ0aW1lb3V0IiwiY2xvc2UiLCJpZCIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwiaXRlbSIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsImFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJyZXF1aXJlIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSUEsUUFBUyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFsQyxJQUNDLE9BQU9DLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLElBRGhDLElBRUFDLE1BRlo7QUFHQSxJQUFJQyxRQUFRQyxTQUFTQyxTQUFULENBQW1CRixLQUEvQjs7QUFFQTs7QUFFQUcsUUFBUUMsVUFBUixHQUFxQixZQUFXO0FBQzlCLFNBQU8sSUFBSUMsT0FBSixDQUFZTCxNQUFNTSxJQUFOLENBQVdGLFVBQVgsRUFBdUJSLEtBQXZCLEVBQThCVyxTQUE5QixDQUFaLEVBQXNEQyxZQUF0RCxDQUFQO0FBQ0QsQ0FGRDtBQUdBTCxRQUFRTSxXQUFSLEdBQXNCLFlBQVc7QUFDL0IsU0FBTyxJQUFJSixPQUFKLENBQVlMLE1BQU1NLElBQU4sQ0FBV0csV0FBWCxFQUF3QmIsS0FBeEIsRUFBK0JXLFNBQS9CLENBQVosRUFBdURHLGFBQXZELENBQVA7QUFDRCxDQUZEO0FBR0FQLFFBQVFLLFlBQVIsR0FDQUwsUUFBUU8sYUFBUixHQUF3QixVQUFTQyxPQUFULEVBQWtCO0FBQ3hDLE1BQUlBLE9BQUosRUFBYTtBQUNYQSxZQUFRQyxLQUFSO0FBQ0Q7QUFDRixDQUxEOztBQU9BLFNBQVNQLE9BQVQsQ0FBaUJRLEVBQWpCLEVBQXFCQyxPQUFyQixFQUE4QjtBQUM1QixPQUFLQyxHQUFMLEdBQVdGLEVBQVg7QUFDQSxPQUFLRyxRQUFMLEdBQWdCRixPQUFoQjtBQUNEO0FBQ0RULFFBQVFILFNBQVIsQ0FBa0JlLEtBQWxCLEdBQTBCWixRQUFRSCxTQUFSLENBQWtCZ0IsR0FBbEIsR0FBd0IsWUFBVyxDQUFFLENBQS9EO0FBQ0FiLFFBQVFILFNBQVIsQ0FBa0JVLEtBQWxCLEdBQTBCLFlBQVc7QUFDbkMsT0FBS0ksUUFBTCxDQUFjVixJQUFkLENBQW1CVixLQUFuQixFQUEwQixLQUFLbUIsR0FBL0I7QUFDRCxDQUZEOztBQUlBO0FBQ0FaLFFBQVFnQixNQUFSLEdBQWlCLFVBQVNDLElBQVQsRUFBZUMsS0FBZixFQUFzQjtBQUNyQ2IsZUFBYVksS0FBS0UsY0FBbEI7QUFDQUYsT0FBS0csWUFBTCxHQUFvQkYsS0FBcEI7QUFDRCxDQUhEOztBQUtBbEIsUUFBUXFCLFFBQVIsR0FBbUIsVUFBU0osSUFBVCxFQUFlO0FBQ2hDWixlQUFhWSxLQUFLRSxjQUFsQjtBQUNBRixPQUFLRyxZQUFMLEdBQW9CLENBQUMsQ0FBckI7QUFDRCxDQUhEOztBQUtBcEIsUUFBUXNCLFlBQVIsR0FBdUJ0QixRQUFRdUIsTUFBUixHQUFpQixVQUFTTixJQUFULEVBQWU7QUFDckRaLGVBQWFZLEtBQUtFLGNBQWxCOztBQUVBLE1BQUlELFFBQVFELEtBQUtHLFlBQWpCO0FBQ0EsTUFBSUYsU0FBUyxDQUFiLEVBQWdCO0FBQ2RELFNBQUtFLGNBQUwsR0FBc0JsQixXQUFXLFNBQVN1QixTQUFULEdBQXFCO0FBQ3BELFVBQUlQLEtBQUtRLFVBQVQsRUFDRVIsS0FBS1EsVUFBTDtBQUNILEtBSHFCLEVBR25CUCxLQUhtQixDQUF0QjtBQUlEO0FBQ0YsQ0FWRDs7QUFZQTtBQUNBLG1CQUFBUSxDQUFRLENBQVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTFCLFFBQVEyQixZQUFSLEdBQXdCLE9BQU9oQyxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxLQUFLZ0MsWUFBckMsSUFDQyxPQUFPakMsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT2lDLFlBRHpDLElBRUMsYUFBUSxVQUFLQSxZQUZyQztBQUdBM0IsUUFBUTRCLGNBQVIsR0FBMEIsT0FBT2pDLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLEtBQUtpQyxjQUFyQyxJQUNDLE9BQU9sQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPa0MsY0FEekMsSUFFQyxhQUFRLFVBQUtBLGNBRnZDLEMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL190aW1lcnMtYnJvd3NlcmlmeUAyLjAuMTBAdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\n(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? undefined : global : self);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3NldGltbWVkaWF0ZUAxLjAuNUBzZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzAxOGIiXSwibmFtZXMiOlsiZ2xvYmFsIiwidW5kZWZpbmVkIiwic2V0SW1tZWRpYXRlIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJkb2N1bWVudCIsInJlZ2lzdGVySW1tZWRpYXRlIiwiY2FsbGJhY2siLCJGdW5jdGlvbiIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImkiLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW4iLCJhcHBseSIsInJ1bklmUHJlc2VudCIsInNldFRpbWVvdXQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhblVzZVBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIk1hdGgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJldmVudCIsInNvdXJjZSIsImRhdGEiLCJpbmRleE9mIiwic2xpY2UiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJ0b1N0cmluZyIsImNhbGwiLCJzZWxmIl0sIm1hcHBpbmdzIjoiOztBQUFDLFdBQVVBLE1BQVYsRUFBa0JDLFNBQWxCLEVBQTZCO0FBQzFCOztBQUVBLFFBQUlELE9BQU9FLFlBQVgsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxRQUFJQyxhQUFhLENBQWpCLENBUDBCLENBT047QUFDcEIsUUFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0EsUUFBSUMsd0JBQXdCLEtBQTVCO0FBQ0EsUUFBSUMsTUFBTU4sT0FBT08sUUFBakI7QUFDQSxRQUFJQyxpQkFBSjs7QUFFQSxhQUFTTixZQUFULENBQXNCTyxRQUF0QixFQUFnQztBQUM5QjtBQUNBLFlBQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0EsdUJBQVcsSUFBSUMsUUFBSixDQUFhLEtBQUtELFFBQWxCLENBQVg7QUFDRDtBQUNEO0FBQ0EsWUFBSUUsT0FBTyxJQUFJQyxLQUFKLENBQVVDLFVBQVVDLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBLGFBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSixLQUFLRyxNQUF6QixFQUFpQ0MsR0FBakMsRUFBc0M7QUFDbENKLGlCQUFLSSxDQUFMLElBQVVGLFVBQVVFLElBQUksQ0FBZCxDQUFWO0FBQ0g7QUFDRDtBQUNBLFlBQUlDLE9BQU8sRUFBRVAsVUFBVUEsUUFBWixFQUFzQkUsTUFBTUEsSUFBNUIsRUFBWDtBQUNBUCxzQkFBY0QsVUFBZCxJQUE0QmEsSUFBNUI7QUFDQVIsMEJBQWtCTCxVQUFsQjtBQUNBLGVBQU9BLFlBQVA7QUFDRDs7QUFFRCxhQUFTYyxjQUFULENBQXdCQyxNQUF4QixFQUFnQztBQUM1QixlQUFPZCxjQUFjYyxNQUFkLENBQVA7QUFDSDs7QUFFRCxhQUFTQyxHQUFULENBQWFILElBQWIsRUFBbUI7QUFDZixZQUFJUCxXQUFXTyxLQUFLUCxRQUFwQjtBQUNBLFlBQUlFLE9BQU9LLEtBQUtMLElBQWhCO0FBQ0EsZ0JBQVFBLEtBQUtHLE1BQWI7QUFDQSxpQkFBSyxDQUFMO0FBQ0lMO0FBQ0E7QUFDSixpQkFBSyxDQUFMO0FBQ0lBLHlCQUFTRSxLQUFLLENBQUwsQ0FBVDtBQUNBO0FBQ0osaUJBQUssQ0FBTDtBQUNJRix5QkFBU0UsS0FBSyxDQUFMLENBQVQsRUFBa0JBLEtBQUssQ0FBTCxDQUFsQjtBQUNBO0FBQ0osaUJBQUssQ0FBTDtBQUNJRix5QkFBU0UsS0FBSyxDQUFMLENBQVQsRUFBa0JBLEtBQUssQ0FBTCxDQUFsQixFQUEyQkEsS0FBSyxDQUFMLENBQTNCO0FBQ0E7QUFDSjtBQUNJRix5QkFBU1csS0FBVCxDQUFlbkIsU0FBZixFQUEwQlUsSUFBMUI7QUFDQTtBQWZKO0FBaUJIOztBQUVELGFBQVNVLFlBQVQsQ0FBc0JILE1BQXRCLEVBQThCO0FBQzFCO0FBQ0E7QUFDQSxZQUFJYixxQkFBSixFQUEyQjtBQUN2QjtBQUNBO0FBQ0FpQix1QkFBV0QsWUFBWCxFQUF5QixDQUF6QixFQUE0QkgsTUFBNUI7QUFDSCxTQUpELE1BSU87QUFDSCxnQkFBSUYsT0FBT1osY0FBY2MsTUFBZCxDQUFYO0FBQ0EsZ0JBQUlGLElBQUosRUFBVTtBQUNOWCx3Q0FBd0IsSUFBeEI7QUFDQSxvQkFBSTtBQUNBYyx3QkFBSUgsSUFBSjtBQUNILGlCQUZELFNBRVU7QUFDTkMsbUNBQWVDLE1BQWY7QUFDQWIsNENBQXdCLEtBQXhCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsYUFBU2tCLDZCQUFULEdBQXlDO0FBQ3JDZiw0QkFBb0IsMkJBQVNVLE1BQVQsRUFBaUI7QUFDakNNLG9CQUFRQyxRQUFSLENBQWlCLFlBQVk7QUFBRUosNkJBQWFILE1BQWI7QUFBdUIsYUFBdEQ7QUFDSCxTQUZEO0FBR0g7O0FBRUQsYUFBU1EsaUJBQVQsR0FBNkI7QUFDekI7QUFDQTtBQUNBLFlBQUkxQixPQUFPMkIsV0FBUCxJQUFzQixDQUFDM0IsT0FBTzRCLGFBQWxDLEVBQWlEO0FBQzdDLGdCQUFJQyw0QkFBNEIsSUFBaEM7QUFDQSxnQkFBSUMsZUFBZTlCLE9BQU8rQixTQUExQjtBQUNBL0IsbUJBQU8rQixTQUFQLEdBQW1CLFlBQVc7QUFDMUJGLDRDQUE0QixLQUE1QjtBQUNILGFBRkQ7QUFHQTdCLG1CQUFPMkIsV0FBUCxDQUFtQixFQUFuQixFQUF1QixHQUF2QjtBQUNBM0IsbUJBQU8rQixTQUFQLEdBQW1CRCxZQUFuQjtBQUNBLG1CQUFPRCx5QkFBUDtBQUNIO0FBQ0o7O0FBRUQsYUFBU0csZ0NBQVQsR0FBNEM7QUFDeEM7QUFDQTtBQUNBOztBQUVBLFlBQUlDLGdCQUFnQixrQkFBa0JDLEtBQUtDLE1BQUwsRUFBbEIsR0FBa0MsR0FBdEQ7QUFDQSxZQUFJQyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVNDLEtBQVQsRUFBZ0I7QUFDbEMsZ0JBQUlBLE1BQU1DLE1BQU4sS0FBaUJ0QyxNQUFqQixJQUNBLE9BQU9xQyxNQUFNRSxJQUFiLEtBQXNCLFFBRHRCLElBRUFGLE1BQU1FLElBQU4sQ0FBV0MsT0FBWCxDQUFtQlAsYUFBbkIsTUFBc0MsQ0FGMUMsRUFFNkM7QUFDekNaLDZCQUFhLENBQUNnQixNQUFNRSxJQUFOLENBQVdFLEtBQVgsQ0FBaUJSLGNBQWNuQixNQUEvQixDQUFkO0FBQ0g7QUFDSixTQU5EOztBQVFBLFlBQUlkLE9BQU8wQyxnQkFBWCxFQUE2QjtBQUN6QjFDLG1CQUFPMEMsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUNOLGVBQW5DLEVBQW9ELEtBQXBEO0FBQ0gsU0FGRCxNQUVPO0FBQ0hwQyxtQkFBTzJDLFdBQVAsQ0FBbUIsV0FBbkIsRUFBZ0NQLGVBQWhDO0FBQ0g7O0FBRUQ1Qiw0QkFBb0IsMkJBQVNVLE1BQVQsRUFBaUI7QUFDakNsQixtQkFBTzJCLFdBQVAsQ0FBbUJNLGdCQUFnQmYsTUFBbkMsRUFBMkMsR0FBM0M7QUFDSCxTQUZEO0FBR0g7O0FBRUQsYUFBUzBCLG1DQUFULEdBQStDO0FBQzNDLFlBQUlDLFVBQVUsSUFBSUMsY0FBSixFQUFkO0FBQ0FELGdCQUFRRSxLQUFSLENBQWNoQixTQUFkLEdBQTBCLFVBQVNNLEtBQVQsRUFBZ0I7QUFDdEMsZ0JBQUluQixTQUFTbUIsTUFBTUUsSUFBbkI7QUFDQWxCLHlCQUFhSCxNQUFiO0FBQ0gsU0FIRDs7QUFLQVYsNEJBQW9CLDJCQUFTVSxNQUFULEVBQWlCO0FBQ2pDMkIsb0JBQVFHLEtBQVIsQ0FBY3JCLFdBQWQsQ0FBMEJULE1BQTFCO0FBQ0gsU0FGRDtBQUdIOztBQUVELGFBQVMrQixxQ0FBVCxHQUFpRDtBQUM3QyxZQUFJQyxPQUFPNUMsSUFBSTZDLGVBQWY7QUFDQTNDLDRCQUFvQiwyQkFBU1UsTUFBVCxFQUFpQjtBQUNqQztBQUNBO0FBQ0EsZ0JBQUlrQyxTQUFTOUMsSUFBSStDLGFBQUosQ0FBa0IsUUFBbEIsQ0FBYjtBQUNBRCxtQkFBT0Usa0JBQVAsR0FBNEIsWUFBWTtBQUNwQ2pDLDZCQUFhSCxNQUFiO0FBQ0FrQyx1QkFBT0Usa0JBQVAsR0FBNEIsSUFBNUI7QUFDQUoscUJBQUtLLFdBQUwsQ0FBaUJILE1BQWpCO0FBQ0FBLHlCQUFTLElBQVQ7QUFDSCxhQUxEO0FBTUFGLGlCQUFLTSxXQUFMLENBQWlCSixNQUFqQjtBQUNILFNBWEQ7QUFZSDs7QUFFRCxhQUFTSywrQkFBVCxHQUEyQztBQUN2Q2pELDRCQUFvQiwyQkFBU1UsTUFBVCxFQUFpQjtBQUNqQ0ksdUJBQVdELFlBQVgsRUFBeUIsQ0FBekIsRUFBNEJILE1BQTVCO0FBQ0gsU0FGRDtBQUdIOztBQUVEO0FBQ0EsUUFBSXdDLFdBQVdDLE9BQU9DLGNBQVAsSUFBeUJELE9BQU9DLGNBQVAsQ0FBc0I1RCxNQUF0QixDQUF4QztBQUNBMEQsZUFBV0EsWUFBWUEsU0FBU3BDLFVBQXJCLEdBQWtDb0MsUUFBbEMsR0FBNkMxRCxNQUF4RDs7QUFFQTtBQUNBLFFBQUksR0FBRzZELFFBQUgsQ0FBWUMsSUFBWixDQUFpQjlELE9BQU93QixPQUF4QixNQUFxQyxrQkFBekMsRUFBNkQ7QUFDekQ7QUFDQUQ7QUFFSCxLQUpELE1BSU8sSUFBSUcsbUJBQUosRUFBeUI7QUFDNUI7QUFDQU07QUFFSCxLQUpNLE1BSUEsSUFBSWhDLE9BQU84QyxjQUFYLEVBQTJCO0FBQzlCO0FBQ0FGO0FBRUgsS0FKTSxNQUlBLElBQUl0QyxPQUFPLHdCQUF3QkEsSUFBSStDLGFBQUosQ0FBa0IsUUFBbEIsQ0FBbkMsRUFBZ0U7QUFDbkU7QUFDQUo7QUFFSCxLQUpNLE1BSUE7QUFDSDtBQUNBUTtBQUNIOztBQUVEQyxhQUFTeEQsWUFBVCxHQUF3QkEsWUFBeEI7QUFDQXdELGFBQVN6QyxjQUFULEdBQTBCQSxjQUExQjtBQUNILENBekxBLEVBeUxDLE9BQU84QyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLE9BQU8vRCxNQUFQLEtBQWtCLFdBQWxCLGVBQXVDQSxNQUFyRSxHQUE4RStELElBekwvRSxDQUFELEMiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fc2V0aW1tZWRpYXRlQDEuMC41QHNldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanM/NTc0MSJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLElBQUlBLFVBQVVDLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUMsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtB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Q0F4RCxRQUFReUQsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7QUFDM0IsVUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEO0FBR0FOLFFBQVEyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxXQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fcHJvY2Vzc0AwLjExLjEwQHByb2Nlc3MvYnJvd3Nlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_14_2_2_vue_loader_lib_selector_type_script_index_0_list_vue__ = __webpack_require__(1);\n/* empty harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_14_2_2_vue_loader_lib_template_compiler_index_id_data_v_c64493b8_hasScoped_false_optionsId_0_buble_transforms_node_modules_vue_loader_14_2_2_vue_loader_lib_selector_type_template_index_0_list_vue__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_14_2_2_vue_loader_lib_runtime_component_normalizer__ = __webpack_require__(14);\nvar disposed = false\nfunction injectStyle (context) {\n  if (disposed) return\n  __webpack_require__(8)\n}\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\n\nvar Component = Object(__WEBPACK_IMPORTED_MODULE_2__node_modules_vue_loader_14_2_2_vue_loader_lib_runtime_component_normalizer__[\"a\" /* default */])(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_14_2_2_vue_loader_lib_selector_type_script_index_0_list_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_14_2_2_vue_loader_lib_template_compiler_index_id_data_v_c64493b8_hasScoped_false_optionsId_0_buble_transforms_node_modules_vue_loader_14_2_2_vue_loader_lib_selector_type_template_index_0_list_vue__[\"a\" /* render */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_14_2_2_vue_loader_lib_template_compiler_index_id_data_v_c64493b8_hasScoped_false_optionsId_0_buble_transforms_node_modules_vue_loader_14_2_2_vue_loader_lib_selector_type_template_index_0_list_vue__[\"b\" /* staticRenderFns */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src\\\\list.vue\"\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-c64493b8\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-c64493b8\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGlzdC52dWU/MGUwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSx1QkFBd047QUFDeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvUTtBQUNwUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKGNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9saXN0LnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vbGlzdC52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9saXN0LnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IHtyZW5kZXIgYXMgX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZucyBhcyBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19ffSBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYzY0NDkzYjhcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2xpc3QudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG5pbXBvcnQgbm9ybWFsaXplQ29tcG9uZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyY1xcXFxsaXN0LnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1jNjQ0OTNiOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWM2NDQ5M2I4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpc3QudnVlXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(11).default\nvar update = add(\"3327d5df\", content, false, {});\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../node_modules/_css-loader@0.28.11@css-loader/index.js?sourceMap!../node_modules/_vue-loader@14.2.2@vue-loader/lib/style-compiler/index.js?{\\\"optionsId\\\":\\\"0\\\",\\\"vue\\\":true,\\\"scoped\\\":false,\\\"sourceMap\\\":true}!../node_modules/_vue-loader@14.2.2@vue-loader/lib/selector.js?type=styles&index=0!./list.vue\", function() {\n     var newContent = require(\"!!../node_modules/_css-loader@0.28.11@css-loader/index.js?sourceMap!../node_modules/_vue-loader@14.2.2@vue-loader/lib/style-compiler/index.js?{\\\"optionsId\\\":\\\"0\\\",\\\"vue\\\":true,\\\"scoped\\\":false,\\\"sourceMap\\\":true}!../node_modules/_vue-loader@14.2.2@vue-loader/lib/selector.js?type=styles&index=0!./list.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGlzdC52dWU/NDVhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG1DQUEyTztBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFLQUFxSyxxRUFBcUU7QUFDMU8sOEtBQThLLHFFQUFxRTtBQUNuUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGlzdC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL192dWUtc3R5bGUtbG9hZGVyQDQuMS4wQHZ1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMzMyN2Q1ZGZcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy9fdnVlLWxvYWRlckAxNC4yLjJAdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy9fdnVlLWxvYWRlckAxNC4yLjJAdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2xpc3QudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uL25vZGVfbW9kdWxlcy9fdnVlLWxvYWRlckAxNC4yLjJAdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy9fdnVlLWxvYWRlckAxNC4yLjJAdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2xpc3QudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fdnVlLXN0eWxlLWxvYWRlckA0LjEuMEB2dWUtc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcIm9wdGlvbnNJZFwiOlwiMFwiLFwidnVlXCI6dHJ1ZSxcInNjb3BlZFwiOmZhbHNlLFwic291cmNlTWFwXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvbGlzdC52dWVcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(10)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"list.vue\",\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGlzdC52dWU/MTVkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLCtEQUFnRSxvRkFBb0Y7O0FBRXBKIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL19jc3MtbG9hZGVyQDAuMjguMTFAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W10sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIlwiLFwiZmlsZVwiOlwibGlzdC52dWVcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fY3NzLWxvYWRlckAwLjI4LjExQGNzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJvcHRpb25zSWRcIjpcIjBcIixcInZ1ZVwiOnRydWUsXCJzY29wZWRcIjpmYWxzZSxcInNvdXJjZU1hcFwiOnRydWV9IS4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2xpc3QudnVlXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz81MTM5Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwidG9TdHJpbmciLCJtYXAiLCJpdGVtIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJqb2luIiwiaSIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImxlbmd0aCIsImlkIiwicHVzaCIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsImNvbmNhdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQTtBQUNBQSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNDLFlBQVQsRUFBdUI7QUFDdkMsS0FBSUMsT0FBTyxFQUFYOztBQUVBO0FBQ0FBLE1BQUtDLFFBQUwsR0FBZ0IsU0FBU0EsUUFBVCxHQUFvQjtBQUNuQyxTQUFPLEtBQUtDLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO0FBQy9CLE9BQUlDLFVBQVVDLHVCQUF1QkYsSUFBdkIsRUFBNkJKLFlBQTdCLENBQWQ7QUFDQSxPQUFHSSxLQUFLLENBQUwsQ0FBSCxFQUFZO0FBQ1gsV0FBTyxZQUFZQSxLQUFLLENBQUwsQ0FBWixHQUFzQixHQUF0QixHQUE0QkMsT0FBNUIsR0FBc0MsR0FBN0M7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPQSxPQUFQO0FBQ0E7QUFDRCxHQVBNLEVBT0pFLElBUEksQ0FPQyxFQVBELENBQVA7QUFRQSxFQVREOztBQVdBO0FBQ0FOLE1BQUtPLENBQUwsR0FBUyxVQUFTQyxPQUFULEVBQWtCQyxVQUFsQixFQUE4QjtBQUN0QyxNQUFHLE9BQU9ELE9BQVAsS0FBbUIsUUFBdEIsRUFDQ0EsVUFBVSxDQUFDLENBQUMsSUFBRCxFQUFPQSxPQUFQLEVBQWdCLEVBQWhCLENBQUQsQ0FBVjtBQUNELE1BQUlFLHlCQUF5QixFQUE3QjtBQUNBLE9BQUksSUFBSUgsSUFBSSxDQUFaLEVBQWVBLElBQUksS0FBS0ksTUFBeEIsRUFBZ0NKLEdBQWhDLEVBQXFDO0FBQ3BDLE9BQUlLLEtBQUssS0FBS0wsQ0FBTCxFQUFRLENBQVIsQ0FBVDtBQUNBLE9BQUcsT0FBT0ssRUFBUCxLQUFjLFFBQWpCLEVBQ0NGLHVCQUF1QkUsRUFBdkIsSUFBNkIsSUFBN0I7QUFDRDtBQUNELE9BQUlMLElBQUksQ0FBUixFQUFXQSxJQUFJQyxRQUFRRyxNQUF2QixFQUErQkosR0FBL0IsRUFBb0M7QUFDbkMsT0FBSUosT0FBT0ssUUFBUUQsQ0FBUixDQUFYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFHLE9BQU9KLEtBQUssQ0FBTCxDQUFQLEtBQW1CLFFBQW5CLElBQStCLENBQUNPLHVCQUF1QlAsS0FBSyxDQUFMLENBQXZCLENBQW5DLEVBQW9FO0FBQ25FLFFBQUdNLGNBQWMsQ0FBQ04sS0FBSyxDQUFMLENBQWxCLEVBQTJCO0FBQzFCQSxVQUFLLENBQUwsSUFBVU0sVUFBVjtBQUNBLEtBRkQsTUFFTyxJQUFHQSxVQUFILEVBQWU7QUFDckJOLFVBQUssQ0FBTCxJQUFVLE1BQU1BLEtBQUssQ0FBTCxDQUFOLEdBQWdCLFNBQWhCLEdBQTRCTSxVQUE1QixHQUF5QyxHQUFuRDtBQUNBO0FBQ0RULFNBQUthLElBQUwsQ0FBVVYsSUFBVjtBQUNBO0FBQ0Q7QUFDRCxFQXhCRDtBQXlCQSxRQUFPSCxJQUFQO0FBQ0EsQ0ExQ0Q7O0FBNENBLFNBQVNLLHNCQUFULENBQWdDRixJQUFoQyxFQUFzQ0osWUFBdEMsRUFBb0Q7QUFDbkQsS0FBSUssVUFBVUQsS0FBSyxDQUFMLEtBQVcsRUFBekI7QUFDQSxLQUFJVyxhQUFhWCxLQUFLLENBQUwsQ0FBakI7QUFDQSxLQUFJLENBQUNXLFVBQUwsRUFBaUI7QUFDaEIsU0FBT1YsT0FBUDtBQUNBOztBQUVELEtBQUlMLGdCQUFnQixPQUFPZ0IsSUFBUCxLQUFnQixVQUFwQyxFQUFnRDtBQUMvQyxNQUFJQyxnQkFBZ0JDLFVBQVVILFVBQVYsQ0FBcEI7QUFDQSxNQUFJSSxhQUFhSixXQUFXSyxPQUFYLENBQW1CakIsR0FBbkIsQ0FBdUIsVUFBVWtCLE1BQVYsRUFBa0I7QUFDekQsVUFBTyxtQkFBbUJOLFdBQVdPLFVBQTlCLEdBQTJDRCxNQUEzQyxHQUFvRCxLQUEzRDtBQUNBLEdBRmdCLENBQWpCOztBQUlBLFNBQU8sQ0FBQ2hCLE9BQUQsRUFBVWtCLE1BQVYsQ0FBaUJKLFVBQWpCLEVBQTZCSSxNQUE3QixDQUFvQyxDQUFDTixhQUFELENBQXBDLEVBQXFEVixJQUFyRCxDQUEwRCxJQUExRCxDQUFQO0FBQ0E7O0FBRUQsUUFBTyxDQUFDRixPQUFELEVBQVVFLElBQVYsQ0FBZSxJQUFmLENBQVA7QUFDQTs7QUFFRDtBQUNBLFNBQVNXLFNBQVQsQ0FBbUJNLFNBQW5CLEVBQThCO0FBQzdCO0FBQ0EsS0FBSUMsU0FBU1QsS0FBS1UsU0FBU0MsbUJBQW1CQyxLQUFLQyxTQUFMLENBQWVMLFNBQWYsQ0FBbkIsQ0FBVCxDQUFMLENBQWI7QUFDQSxLQUFJTSxPQUFPLGlFQUFpRUwsTUFBNUU7O0FBRUEsUUFBTyxTQUFTSyxJQUFULEdBQWdCLEtBQXZCO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvX2Nzcy1sb2FkZXJAMC4yOC4xMUBjc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"default\"] = addStylesClient;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listToStyles__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listToStyles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__listToStyles__);\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = __WEBPACK_IMPORTED_MODULE_0__listToStyles___default()(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = __WEBPACK_IMPORTED_MODULE_0__listToStyles___default()(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Z1ZS1zdHlsZS1sb2FkZXJANC4xLjBAdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzP2JhYjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbmltcG9ydCBsaXN0VG9TdHlsZXMgZnJvbSAnLi9saXN0VG9TdHlsZXMnXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fdnVlLXN0eWxlLWxvYWRlckA0LjEuMEB2dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = listToStyles;\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles(parentId, list) {\n  var styles = [];\n  var newStyles = {};\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n  return styles;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Z1ZS1zdHlsZS1sb2FkZXJANC4xLjBAdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzP2U2NDgiXSwibmFtZXMiOlsibGlzdFRvU3R5bGVzIiwicGFyZW50SWQiLCJsaXN0Iiwic3R5bGVzIiwibmV3U3R5bGVzIiwiaSIsImxlbmd0aCIsIml0ZW0iLCJpZCIsImNzcyIsIm1lZGlhIiwic291cmNlTWFwIiwicGFydCIsInB1c2giLCJwYXJ0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBSXdCQSxZO0FBSnhCOzs7O0FBSWUsU0FBU0EsWUFBVCxDQUF1QkMsUUFBdkIsRUFBaUNDLElBQWpDLEVBQXVDO0FBQ3BELE1BQUlDLFNBQVMsRUFBYjtBQUNBLE1BQUlDLFlBQVksRUFBaEI7QUFDQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUgsS0FBS0ksTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO0FBQ3BDLFFBQUlFLE9BQU9MLEtBQUtHLENBQUwsQ0FBWDtBQUNBLFFBQUlHLEtBQUtELEtBQUssQ0FBTCxDQUFUO0FBQ0EsUUFBSUUsTUFBTUYsS0FBSyxDQUFMLENBQVY7QUFDQSxRQUFJRyxRQUFRSCxLQUFLLENBQUwsQ0FBWjtBQUNBLFFBQUlJLFlBQVlKLEtBQUssQ0FBTCxDQUFoQjtBQUNBLFFBQUlLLE9BQU87QUFDVEosVUFBSVAsV0FBVyxHQUFYLEdBQWlCSSxDQURaO0FBRVRJLFdBQUtBLEdBRkk7QUFHVEMsYUFBT0EsS0FIRTtBQUlUQyxpQkFBV0E7QUFKRixLQUFYO0FBTUEsUUFBSSxDQUFDUCxVQUFVSSxFQUFWLENBQUwsRUFBb0I7QUFDbEJMLGFBQU9VLElBQVAsQ0FBWVQsVUFBVUksRUFBVixJQUFnQixFQUFFQSxJQUFJQSxFQUFOLEVBQVVNLE9BQU8sQ0FBQ0YsSUFBRCxDQUFqQixFQUE1QjtBQUNELEtBRkQsTUFFTztBQUNMUixnQkFBVUksRUFBVixFQUFjTSxLQUFkLENBQW9CRCxJQUFwQixDQUF5QkQsSUFBekI7QUFDRDtBQUNGO0FBQ0QsU0FBT1QsTUFBUDtBQUNEIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9fdnVlLXN0eWxlLWxvYWRlckA0LjEuMEB2dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [_vm._v(\"\\n\\t\" + _vm._s(_vm.nbame) + \"\\n\")])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n    require(\"vue-loader/node_modules/vue-hot-reload-api\")      .rerender(\"data-v-c64493b8\", { render: render, staticRenderFns: staticRenderFns })\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGlzdC52dWU/MzhhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1E7QUFDUjtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsbURBQW1EO0FBQ2hKO0FBQ0EiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtfdm0uX3YoXCJcXG5cXHRcIiArIF92bS5fcyhfdm0ubmJhbWUpICsgXCJcXG5cIildKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYzY0NDkzYjhcIiwgeyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfSlcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL192dWUtbG9hZGVyQDE0LjIuMkB2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWM2NDQ5M2I4XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcIm9wdGlvbnNJZFwiOlwiMFwiLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy9fdnVlLWxvYWRlckAxNC4yLjJAdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2xpc3QudnVlXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = normalizeComponent;\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  scriptExports = scriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof scriptExports.default\n  if (type === 'object' || type === 'function') {\n    scriptExports = scriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3Z1ZS1sb2FkZXJAMTQuMi4yQHZ1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/ZDdjMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgc2NyaXB0RXhwb3J0cyA9IHNjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNjcmlwdEV4cG9ydHMgPSBzY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fdnVlLWxvYWRlckAxNC4yLjJAdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n");

/***/ })
/******/ ]);